(function e(t, n, r) {
  function s(o, u) {
    if (!n[o]) {
      if (!t[o]) {
        const a = typeof require === 'function' && require;
        if (!u && a) return a(o, !0);
        if (i) return i(o, !0);
        const f = new Error(`Cannot find module '${o}'`);
        throw ((f.code = 'MODULE_NOT_FOUND'), f);
      }
      const l = (n[o] = { exports: {} });
      t[o][0].call(
        l.exports,
        function (e) {
          const n = t[o][1][e];
          return s(n || e);
        },
        l,
        l.exports,
        e,
        t,
        n,
        r
      );
    }
    return n[o].exports;
  }
  var i = typeof require === 'function' && require;
  for (let o = 0; o < r.length; o++) s(r[o]);
  return s;
})(
  {
    1: [
      function (require, module, exports) {
        module.exports = {
          jet: [
            { index: 0, rgb: [0, 0, 131] },
            { index: 0.125, rgb: [0, 60, 170] },
            { index: 0.375, rgb: [5, 255, 255] },
            { index: 0.625, rgb: [255, 255, 0] },
            { index: 0.875, rgb: [250, 0, 0] },
            { index: 1, rgb: [128, 0, 0] }
          ],
          hsv: [
            { index: 0, rgb: [255, 0, 0] },
            { index: 0.169, rgb: [253, 255, 2] },
            { index: 0.173, rgb: [247, 255, 2] },
            { index: 0.337, rgb: [0, 252, 4] },
            { index: 0.341, rgb: [0, 252, 10] },
            { index: 0.506, rgb: [1, 249, 255] },
            { index: 0.671, rgb: [2, 0, 253] },
            { index: 0.675, rgb: [8, 0, 253] },
            { index: 0.839, rgb: [255, 0, 251] },
            { index: 0.843, rgb: [255, 0, 245] },
            { index: 1, rgb: [255, 0, 6] }
          ],
          hot: [
            { index: 0, rgb: [0, 0, 0] },
            { index: 0.3, rgb: [230, 0, 0] },
            { index: 0.6, rgb: [255, 210, 0] },
            { index: 1, rgb: [255, 255, 255] }
          ],
          cool: [
            { index: 0, rgb: [0, 255, 255] },
            { index: 1, rgb: [255, 0, 255] }
          ],
          spring: [
            { index: 0, rgb: [255, 0, 255] },
            { index: 1, rgb: [255, 255, 0] }
          ],
          summer: [
            { index: 0, rgb: [0, 128, 102] },
            { index: 1, rgb: [255, 255, 102] }
          ],
          autumn: [
            { index: 0, rgb: [255, 0, 0] },
            { index: 1, rgb: [255, 255, 0] }
          ],
          winter: [
            { index: 0, rgb: [0, 0, 255] },
            { index: 1, rgb: [0, 255, 128] }
          ],
          bone: [
            { index: 0, rgb: [0, 0, 0] },
            { index: 0.376, rgb: [84, 84, 116] },
            { index: 0.753, rgb: [169, 200, 200] },
            { index: 1, rgb: [255, 255, 255] }
          ],
          copper: [
            { index: 0, rgb: [0, 0, 0] },
            { index: 0.804, rgb: [255, 160, 102] },
            { index: 1, rgb: [255, 199, 127] }
          ],
          greys: [
            { index: 0, rgb: [0, 0, 0] },
            { index: 1, rgb: [255, 255, 255] }
          ],
          yignbu: [
            { index: 0, rgb: [8, 29, 88] },
            { index: 0.125, rgb: [37, 52, 148] },
            { index: 0.25, rgb: [34, 94, 168] },
            { index: 0.375, rgb: [29, 145, 192] },
            { index: 0.5, rgb: [65, 182, 196] },
            { index: 0.625, rgb: [127, 205, 187] },
            { index: 0.75, rgb: [199, 233, 180] },
            { index: 0.875, rgb: [237, 248, 217] },
            { index: 1, rgb: [255, 255, 217] }
          ],
          greens: [
            { index: 0, rgb: [0, 68, 27] },
            { index: 0.125, rgb: [0, 109, 44] },
            { index: 0.25, rgb: [35, 139, 69] },
            { index: 0.375, rgb: [65, 171, 93] },
            { index: 0.5, rgb: [116, 196, 118] },
            { index: 0.625, rgb: [161, 217, 155] },
            { index: 0.75, rgb: [199, 233, 192] },
            { index: 0.875, rgb: [229, 245, 224] },
            { index: 1, rgb: [247, 252, 245] }
          ],
          yiorrd: [
            { index: 0, rgb: [128, 0, 38] },
            { index: 0.125, rgb: [189, 0, 38] },
            { index: 0.25, rgb: [227, 26, 28] },
            { index: 0.375, rgb: [252, 78, 42] },
            { index: 0.5, rgb: [253, 141, 60] },
            { index: 0.625, rgb: [254, 178, 76] },
            { index: 0.75, rgb: [254, 217, 118] },
            { index: 0.875, rgb: [255, 237, 160] },
            { index: 1, rgb: [255, 255, 204] }
          ],
          bluered: [
            { index: 0, rgb: [0, 0, 255] },
            { index: 1, rgb: [255, 0, 0] }
          ],
          rdbu: [
            { index: 0, rgb: [5, 10, 172] },
            { index: 0.35, rgb: [106, 137, 247] },
            { index: 0.5, rgb: [190, 190, 190] },
            { index: 0.6, rgb: [220, 170, 132] },
            { index: 0.7, rgb: [230, 145, 90] },
            { index: 1, rgb: [178, 10, 28] }
          ],
          picnic: [
            { index: 0, rgb: [0, 0, 255] },
            { index: 0.1, rgb: [51, 153, 255] },
            { index: 0.2, rgb: [102, 204, 255] },
            { index: 0.3, rgb: [153, 204, 255] },
            { index: 0.4, rgb: [204, 204, 255] },
            { index: 0.5, rgb: [255, 255, 255] },
            { index: 0.6, rgb: [255, 204, 255] },
            { index: 0.7, rgb: [255, 153, 255] },
            { index: 0.8, rgb: [255, 102, 204] },
            { index: 0.9, rgb: [255, 102, 102] },
            { index: 1, rgb: [255, 0, 0] }
          ],
          rainbow: [
            { index: 0, rgb: [150, 0, 90] },
            { index: 0.125, rgb: [0, 0, 200] },
            { index: 0.25, rgb: [0, 25, 255] },
            { index: 0.375, rgb: [0, 152, 255] },
            { index: 0.5, rgb: [44, 255, 150] },
            { index: 0.625, rgb: [151, 255, 0] },
            { index: 0.75, rgb: [255, 234, 0] },
            { index: 0.875, rgb: [255, 111, 0] },
            { index: 1, rgb: [255, 0, 0] }
          ],
          portland: [
            { index: 0, rgb: [12, 51, 131] },
            { index: 0.25, rgb: [10, 136, 186] },
            { index: 0.5, rgb: [242, 211, 56] },
            { index: 0.75, rgb: [242, 143, 56] },
            { index: 1, rgb: [217, 30, 30] }
          ],
          blackbody: [
            { index: 0, rgb: [0, 0, 0] },
            { index: 0.2, rgb: [230, 0, 0] },
            { index: 0.4, rgb: [230, 210, 0] },
            { index: 0.7, rgb: [255, 255, 255] },
            { index: 1, rgb: [160, 200, 255] }
          ],
          earth: [
            { index: 0, rgb: [0, 0, 130] },
            { index: 0.1, rgb: [0, 180, 180] },
            { index: 0.2, rgb: [40, 210, 40] },
            { index: 0.4, rgb: [230, 230, 50] },
            { index: 0.6, rgb: [120, 70, 20] },
            { index: 1, rgb: [255, 255, 255] }
          ],
          electric: [
            { index: 0, rgb: [0, 0, 0] },
            { index: 0.15, rgb: [30, 0, 100] },
            { index: 0.4, rgb: [120, 0, 100] },
            { index: 0.6, rgb: [160, 90, 0] },
            { index: 0.8, rgb: [230, 200, 0] },
            { index: 1, rgb: [255, 250, 220] }
          ],
          alpha: [
            { index: 0, rgb: [255, 255, 255, 0] },
            { index: 0, rgb: [255, 255, 255, 1] }
          ]
        };
      },
      {}
    ],
    2: [
      function (require, module, exports) {
        /*
         * Ben Postlethwaite
         * January 2013
         * License MIT
         */

        const at = require('arraytools');
        const clone = require('clone');
        const colorScale = require('./colorScales');
        module.exports = function (spec) {
          let indicies;
          let rgba;
          let fromrgba;
          let torgba;
          let nsteps;
          let cmap;
          let colormap;
          let format;
          let nshades;
          let colors;
          let alpha;
          let index;
          let i;
          let r = [];
          let g = [];
          let b = [];
          let a = [];
          if (!at.isPlainObject(spec)) spec = {};
          nshades = spec.nshades || 72;
          format = spec.format || 'hex';
          colormap = spec.colormap;
          if (!colormap) colormap = 'jet';
          if (typeof colormap === 'string') {
            colormap = colormap.toLowerCase();
            if (!colorScale[colormap]) {
              throw Error(`${colormap} not a supported colorscale`);
            }
            cmap = clone(colorScale[colormap]);
          } else if (Array.isArray(colormap)) {
            cmap = clone(colormap);
          } else {
            throw Error('unsupported colormap option', colormap);
          }
          if (cmap.length > nshades) {
            throw new Error(`${colormap} map requires nshades to be at least size ${cmap.length}`);
          }
          if (!Array.isArray(spec.alpha)) {
            if (typeof spec.alpha === 'number') {
              alpha = [spec.alpha, spec.alpha];
            } else {
              alpha = [1, 1];
            }
          } else if (spec.alpha.length !== 2) {
            alpha = [1, 1];
          } else {
            alpha = clone(spec.alpha);
          }
          indicies = cmap.map(function (c) {
            return Math.round(c.index * nshades);
          });
          if (alpha[0] < 0) alpha[0] = 0;
          if (alpha[1] < 0) alpha[0] = 0;
          if (alpha[0] > 1) alpha[0] = 1;
          if (alpha[1] > 1) alpha[0] = 1;
          for (i = 0; i < indicies.length; ++i) {
            index = cmap[i].index;
            rgba = cmap[i].rgb;
            if (rgba.length === 4 && rgba[3] >= 0 && rgba[3] <= 1) continue;
            rgba[3] = alpha[0] + (alpha[1] - alpha[0]) * index;
          }
          for (i = 0; i < indicies.length - 1; ++i) {
            nsteps = indicies[i + 1] - indicies[i];
            fromrgba = cmap[i].rgb;
            torgba = cmap[i + 1].rgb;
            r = r.concat(at.linspace(fromrgba[0], torgba[0], nsteps));
            g = g.concat(at.linspace(fromrgba[1], torgba[1], nsteps));
            b = b.concat(at.linspace(fromrgba[2], torgba[2], nsteps));
            a = a.concat(at.linspace(fromrgba[3], torgba[3], nsteps));
          }
          r = r.map(Math.round);
          g = g.map(Math.round);
          b = b.map(Math.round);
          colors = at.zip(r, g, b, a);
          if (format === 'hex') colors = colors.map(rgb2hex);
          if (format === 'rgbaString') colors = colors.map(rgbaStr);
          return colors;
        };
        function rgb2hex(rgba) {
          let dig;
          let hex = '#';
          for (let i = 0; i < 3; ++i) {
            dig = rgba[i];
            dig = dig.toString(16);
            hex += `00${dig}`.substr(dig.length);
          }
          return hex;
        }
        function rgbaStr(rgba) {
          return `rgba(${rgba.join(',')})`;
        }
      },
      { './colorScales': 1, arraytools: 3, clone: 4 }
    ],
    3: [
      function (require, module, exports) {
        const arraytools = function () {
          const that = {};
          const RGB_REGEX = /^rgba?\(\s*\d{1,3}\s*,\s*\d{1,3}\s*,\s*\d{1,3}\s*(,.*)?\)$/;
          const RGB_GROUP_REGEX =
            /^rgba?\(\s*(\d{1,3})\s*,\s*(\d{1,3})\s*,\s*(\d{1,3})\s*,?\s*(.*)?\)$/;
          function isPlainObject(v) {
            return !Array.isArray(v) && v !== null && typeof v === 'object';
          }
          function linspace(start, end, num) {
            const inc = (end - start) / Math.max(num - 1, 1);
            const a = [];
            for (let ii = 0; ii < num; ii++) a.push(start + ii * inc);
            return a;
          }
          function zip() {
            const arrays = [].slice.call(arguments);
            const lengths = arrays.map(function (a) {
              return a.length;
            });
            const len = Math.min.apply(null, lengths);
            const zipped = [];
            for (let i = 0; i < len; i++) {
              zipped[i] = [];
              for (let j = 0; j < arrays.length; ++j) {
                zipped[i][j] = arrays[j][i];
              }
            }
            return zipped;
          }
          function zip3(a, b, c) {
            const len = Math.min.apply(null, [a.length, b.length, c.length]);
            const result = [];
            for (let n = 0; n < len; n++) {
              result.push([a[n], b[n], c[n]]);
            }
            return result;
          }
          function sum(A) {
            let acc = 0;
            accumulate(A, acc);
            function accumulate(x) {
              for (let i = 0; i < x.length; i++) {
                if (Array.isArray(x[i])) accumulate(x[i], acc);
                else acc += x[i];
              }
            }
            return acc;
          }
          function copy2D(arr) {
            const carr = [];
            for (let i = 0; i < arr.length; ++i) {
              carr[i] = [];
              for (let j = 0; j < arr[i].length; ++j) {
                carr[i][j] = arr[i][j];
              }
            }
            return carr;
          }
          function copy1D(arr) {
            const carr = [];
            for (let i = 0; i < arr.length; ++i) {
              carr[i] = arr[i];
            }
            return carr;
          }
          function isEqual(arr1, arr2) {
            if (arr1.length !== arr2.length) return false;
            for (let i = arr1.length; i--; ) {
              if (arr1[i] !== arr2[i]) return false;
            }
            return true;
          }
          function str2RgbArray(str, twoFiftySix) {
            let rgb;
            let match;
            if (typeof str !== 'string') return str;
            rgb = [];
            if (str[0] === '#') {
              str = str.substr(1);
              if (str.length === 3) str += str;
              match = parseInt(str, 16);
              rgb[0] = (match >> 16) & 255;
              rgb[1] = (match >> 8) & 255;
              rgb[2] = match & 255;
            } else if (RGB_REGEX.test(str)) {
              match = str.match(RGB_GROUP_REGEX);
              rgb[0] = parseInt(match[1]);
              rgb[1] = parseInt(match[2]);
              rgb[2] = parseInt(match[3]);
            }
            if (!twoFiftySix) {
              for (let j = 0; j < 3; ++j) rgb[j] = rgb[j] / 255;
            }
            return rgb;
          }
          function str2RgbaArray(str, twoFiftySix) {
            let rgb;
            let match;
            if (typeof str !== 'string') return str;
            rgb = [];
            if (str[0] === '#') {
              str = str.substr(1);
              if (str.length === 3) str += str;
              match = parseInt(str, 16);
              rgb[0] = (match >> 16) & 255;
              rgb[1] = (match >> 8) & 255;
              rgb[2] = match & 255;
            } else if (RGB_REGEX.test(str)) {
              match = str.match(RGB_GROUP_REGEX);
              rgb[0] = parseInt(match[1]);
              rgb[1] = parseInt(match[2]);
              rgb[2] = parseInt(match[3]);
              if (match[4]) rgb[3] = parseFloat(match[4]);
              else rgb[3] = 1;
            }
            if (!twoFiftySix) {
              for (let j = 0; j < 3; ++j) rgb[j] = rgb[j] / 255;
            }
            return rgb;
          }
          that.isPlainObject = isPlainObject;
          that.linspace = linspace;
          that.zip3 = zip3;
          that.sum = sum;
          that.zip = zip;
          that.isEqual = isEqual;
          that.copy2D = copy2D;
          that.copy1D = copy1D;
          that.str2RgbArray = str2RgbArray;
          that.str2RgbaArray = str2RgbaArray;
          return that;
        };
        module.exports = arraytools();
      },
      {}
    ],
    4: [
      function (require, module, exports) {
        (function (Buffer) {
          const clone = (function () {
            function clone(parent, circular, depth, prototype) {
              let filter;
              if (typeof circular === 'object') {
                depth = circular.depth;
                prototype = circular.prototype;
                filter = circular.filter;
                circular = circular.circular;
              }
              const allParents = [];
              const allChildren = [];
              const useBuffer = typeof Buffer !== 'undefined';
              if (typeof circular === 'undefined') circular = true;
              if (typeof depth === 'undefined') depth = Infinity;
              function _clone(parent, depth) {
                if (parent === null) return null;
                if (depth == 0) return parent;
                let child;
                let proto;
                if (typeof parent !== 'object') {
                  return parent;
                }
                if (clone.__isArray(parent)) {
                  child = [];
                } else if (clone.__isRegExp(parent)) {
                  child = new RegExp(parent.source, __getRegExpFlags(parent));
                  if (parent.lastIndex) child.lastIndex = parent.lastIndex;
                } else if (clone.__isDate(parent)) {
                  child = new Date(parent.getTime());
                } else if (useBuffer && Buffer.isBuffer(parent)) {
                  child = new Buffer(parent.length);
                  parent.copy(child);
                  return child;
                } else if (typeof prototype === 'undefined') {
                  proto = Object.getPrototypeOf(parent);
                  child = Object.create(proto);
                } else {
                  child = Object.create(prototype);
                  proto = prototype;
                }
                if (circular) {
                  const index = allParents.indexOf(parent);
                  if (index != -1) {
                    return allChildren[index];
                  }
                  allParents.push(parent);
                  allChildren.push(child);
                }
                for (const i in parent) {
                  var attrs;
                  if (proto) {
                    attrs = Object.getOwnPropertyDescriptor(proto, i);
                  }
                  if (attrs && attrs.set == null) {
                    continue;
                  }
                  child[i] = _clone(parent[i], depth - 1);
                }
                return child;
              }
              return _clone(parent, depth);
            }
            clone.clonePrototype = function clonePrototype(parent) {
              if (parent === null) return null;
              const c = function () {};
              c.prototype = parent;
              return new c();
            };
            function __objToStr(o) {
              return Object.prototype.toString.call(o);
            }
            clone.__objToStr = __objToStr;
            function __isDate(o) {
              return typeof o === 'object' && __objToStr(o) === '[object Date]';
            }
            clone.__isDate = __isDate;
            function __isArray(o) {
              return typeof o === 'object' && __objToStr(o) === '[object Array]';
            }
            clone.__isArray = __isArray;
            function __isRegExp(o) {
              return typeof o === 'object' && __objToStr(o) === '[object RegExp]';
            }
            clone.__isRegExp = __isRegExp;
            function __getRegExpFlags(re) {
              let flags = '';
              if (re.global) flags += 'g';
              if (re.ignoreCase) flags += 'i';
              if (re.multiline) flags += 'm';
              return flags;
            }
            clone.__getRegExpFlags = __getRegExpFlags;
            return clone;
          })();
          if (typeof module === 'object' && module.exports) {
            module.exports = clone;
          }
        }.call(this, require('buffer').Buffer));
      },
      { buffer: 6 }
    ],
    5: [
      function (require, module, exports) {
        window.colormap = require('colormap');
        window.magma = [
          { index: 0, rgb: [0, 0, 4] },
          { index: 0.0039, rgb: [1, 0, 5] },
          { index: 0.0078, rgb: [1, 1, 6] },
          { index: 0.0118, rgb: [1, 1, 8] },
          { index: 0.0157, rgb: [2, 1, 9] },
          { index: 0.0196, rgb: [2, 2, 11] },
          { index: 0.0235, rgb: [2, 2, 13] },
          { index: 0.0275, rgb: [3, 3, 15] },
          { index: 0.0314, rgb: [3, 3, 18] },
          { index: 0.0353, rgb: [4, 4, 20] },
          { index: 0.0392, rgb: [5, 4, 22] },
          { index: 0.0431, rgb: [6, 5, 24] },
          { index: 0.0471, rgb: [6, 5, 26] },
          { index: 0.051, rgb: [7, 6, 28] },
          { index: 0.0549, rgb: [8, 7, 30] },
          { index: 0.0588, rgb: [9, 7, 32] },
          { index: 0.0627, rgb: [10, 8, 34] },
          { index: 0.0667, rgb: [11, 9, 36] },
          { index: 0.0706, rgb: [12, 9, 38] },
          { index: 0.0745, rgb: [13, 10, 41] },
          { index: 0.0784, rgb: [14, 11, 43] },
          { index: 0.0824, rgb: [16, 11, 45] },
          { index: 0.0863, rgb: [17, 12, 47] },
          { index: 0.0902, rgb: [18, 13, 49] },
          { index: 0.0941, rgb: [19, 13, 52] },
          { index: 0.098, rgb: [20, 14, 54] },
          { index: 0.102, rgb: [21, 14, 56] },
          { index: 0.1059, rgb: [22, 15, 59] },
          { index: 0.1098, rgb: [24, 15, 61] },
          { index: 0.1137, rgb: [25, 16, 63] },
          { index: 0.1176, rgb: [26, 16, 66] },
          { index: 0.1216, rgb: [28, 16, 68] },
          { index: 0.1255, rgb: [29, 17, 71] },
          { index: 0.1294, rgb: [30, 17, 73] },
          { index: 0.1333, rgb: [32, 17, 75] },
          { index: 0.1373, rgb: [33, 17, 78] },
          { index: 0.1412, rgb: [34, 17, 80] },
          { index: 0.1451, rgb: [36, 18, 83] },
          { index: 0.149, rgb: [37, 18, 85] },
          { index: 0.1529, rgb: [39, 18, 88] },
          { index: 0.1569, rgb: [41, 17, 90] },
          { index: 0.1608, rgb: [42, 17, 92] },
          { index: 0.1647, rgb: [44, 17, 95] },
          { index: 0.1686, rgb: [45, 17, 97] },
          { index: 0.1725, rgb: [47, 17, 99] },
          { index: 0.1765, rgb: [49, 17, 101] },
          { index: 0.1804, rgb: [51, 16, 103] },
          { index: 0.1843, rgb: [52, 16, 105] },
          { index: 0.1882, rgb: [54, 16, 107] },
          { index: 0.1922, rgb: [56, 16, 108] },
          { index: 0.1961, rgb: [57, 15, 110] },
          { index: 0.2, rgb: [59, 15, 112] },
          { index: 0.2039, rgb: [61, 15, 113] },
          { index: 0.2078, rgb: [63, 15, 114] },
          { index: 0.2118, rgb: [64, 15, 116] },
          { index: 0.2157, rgb: [66, 15, 117] },
          { index: 0.2196, rgb: [68, 15, 118] },
          { index: 0.2235, rgb: [69, 16, 119] },
          { index: 0.2275, rgb: [71, 16, 120] },
          { index: 0.2314, rgb: [73, 16, 120] },
          { index: 0.2353, rgb: [74, 16, 121] },
          { index: 0.2392, rgb: [76, 17, 122] },
          { index: 0.2431, rgb: [78, 17, 123] },
          { index: 0.2471, rgb: [79, 18, 123] },
          { index: 0.251, rgb: [81, 18, 124] },
          { index: 0.2549, rgb: [82, 19, 124] },
          { index: 0.2588, rgb: [84, 19, 125] },
          { index: 0.2627, rgb: [86, 20, 125] },
          { index: 0.2667, rgb: [87, 21, 126] },
          { index: 0.2706, rgb: [89, 21, 126] },
          { index: 0.2745, rgb: [90, 22, 126] },
          { index: 0.2784, rgb: [92, 22, 127] },
          { index: 0.2824, rgb: [93, 23, 127] },
          { index: 0.2863, rgb: [95, 24, 127] },
          { index: 0.2902, rgb: [96, 24, 128] },
          { index: 0.2941, rgb: [98, 25, 128] },
          { index: 0.298, rgb: [100, 26, 128] },
          { index: 0.302, rgb: [101, 26, 128] },
          { index: 0.3059, rgb: [103, 27, 128] },
          { index: 0.3098, rgb: [104, 28, 129] },
          { index: 0.3137, rgb: [106, 28, 129] },
          { index: 0.3176, rgb: [107, 29, 129] },
          { index: 0.3216, rgb: [109, 29, 129] },
          { index: 0.3255, rgb: [110, 30, 129] },
          { index: 0.3294, rgb: [112, 31, 129] },
          { index: 0.3333, rgb: [114, 31, 129] },
          { index: 0.3373, rgb: [115, 32, 129] },
          { index: 0.3412, rgb: [117, 33, 129] },
          { index: 0.3451, rgb: [118, 33, 129] },
          { index: 0.349, rgb: [120, 34, 129] },
          { index: 0.3529, rgb: [121, 34, 130] },
          { index: 0.3569, rgb: [123, 35, 130] },
          { index: 0.3608, rgb: [124, 35, 130] },
          { index: 0.3647, rgb: [126, 36, 130] },
          { index: 0.3686, rgb: [128, 37, 130] },
          { index: 0.3725, rgb: [129, 37, 129] },
          { index: 0.3765, rgb: [131, 38, 129] },
          { index: 0.3804, rgb: [132, 38, 129] },
          { index: 0.3843, rgb: [134, 39, 129] },
          { index: 0.3882, rgb: [136, 39, 129] },
          { index: 0.3922, rgb: [137, 40, 129] },
          { index: 0.3961, rgb: [139, 41, 129] },
          { index: 0.4, rgb: [140, 41, 129] },
          { index: 0.4039, rgb: [142, 42, 129] },
          { index: 0.4078, rgb: [144, 42, 129] },
          { index: 0.4118, rgb: [145, 43, 129] },
          { index: 0.4157, rgb: [147, 43, 128] },
          { index: 0.4196, rgb: [148, 44, 128] },
          { index: 0.4235, rgb: [150, 44, 128] },
          { index: 0.4275, rgb: [152, 45, 128] },
          { index: 0.4314, rgb: [153, 45, 128] },
          { index: 0.4353, rgb: [155, 46, 127] },
          { index: 0.4392, rgb: [156, 46, 127] },
          { index: 0.4431, rgb: [158, 47, 127] },
          { index: 0.4471, rgb: [160, 47, 127] },
          { index: 0.451, rgb: [161, 48, 126] },
          { index: 0.4549, rgb: [163, 48, 126] },
          { index: 0.4588, rgb: [165, 49, 126] },
          { index: 0.4627, rgb: [166, 49, 125] },
          { index: 0.4667, rgb: [168, 50, 125] },
          { index: 0.4706, rgb: [170, 51, 125] },
          { index: 0.4745, rgb: [171, 51, 124] },
          { index: 0.4784, rgb: [173, 52, 124] },
          { index: 0.4824, rgb: [174, 52, 123] },
          { index: 0.4863, rgb: [176, 53, 123] },
          { index: 0.4902, rgb: [178, 53, 123] },
          { index: 0.4941, rgb: [179, 54, 122] },
          { index: 0.498, rgb: [181, 54, 122] },
          { index: 0.502, rgb: [183, 55, 121] },
          { index: 0.5059, rgb: [184, 55, 121] },
          { index: 0.5098, rgb: [186, 56, 120] },
          { index: 0.5137, rgb: [188, 57, 120] },
          { index: 0.5176, rgb: [189, 57, 119] },
          { index: 0.5216, rgb: [191, 58, 119] },
          { index: 0.5255, rgb: [192, 58, 118] },
          { index: 0.5294, rgb: [194, 59, 117] },
          { index: 0.5333, rgb: [196, 60, 117] },
          { index: 0.5373, rgb: [197, 60, 116] },
          { index: 0.5412, rgb: [199, 61, 115] },
          { index: 0.5451, rgb: [200, 62, 115] },
          { index: 0.549, rgb: [202, 62, 114] },
          { index: 0.5529, rgb: [204, 63, 113] },
          { index: 0.5569, rgb: [205, 64, 113] },
          { index: 0.5608, rgb: [207, 64, 112] },
          { index: 0.5647, rgb: [208, 65, 111] },
          { index: 0.5686, rgb: [210, 66, 111] },
          { index: 0.5725, rgb: [211, 67, 110] },
          { index: 0.5765, rgb: [213, 68, 109] },
          { index: 0.5804, rgb: [214, 69, 108] },
          { index: 0.5843, rgb: [216, 69, 108] },
          { index: 0.5882, rgb: [217, 70, 107] },
          { index: 0.5922, rgb: [219, 71, 106] },
          { index: 0.5961, rgb: [220, 72, 105] },
          { index: 0.6, rgb: [222, 73, 104] },
          { index: 0.6039, rgb: [223, 74, 104] },
          { index: 0.6078, rgb: [224, 76, 103] },
          { index: 0.6118, rgb: [226, 77, 102] },
          { index: 0.6157, rgb: [227, 78, 101] },
          { index: 0.6196, rgb: [228, 79, 100] },
          { index: 0.6235, rgb: [229, 80, 100] },
          { index: 0.6275, rgb: [231, 82, 99] },
          { index: 0.6314, rgb: [232, 83, 98] },
          { index: 0.6353, rgb: [233, 84, 98] },
          { index: 0.6392, rgb: [234, 86, 97] },
          { index: 0.6431, rgb: [235, 87, 96] },
          { index: 0.6471, rgb: [236, 88, 96] },
          { index: 0.651, rgb: [237, 90, 95] },
          { index: 0.6549, rgb: [238, 91, 94] },
          { index: 0.6588, rgb: [239, 93, 94] },
          { index: 0.6627, rgb: [240, 95, 94] },
          { index: 0.6667, rgb: [241, 96, 93] },
          { index: 0.6706, rgb: [242, 98, 93] },
          { index: 0.6745, rgb: [242, 100, 92] },
          { index: 0.6784, rgb: [243, 101, 92] },
          { index: 0.6824, rgb: [244, 103, 92] },
          { index: 0.6863, rgb: [244, 105, 92] },
          { index: 0.6902, rgb: [245, 107, 92] },
          { index: 0.6941, rgb: [246, 108, 92] },
          { index: 0.698, rgb: [246, 110, 92] },
          { index: 0.702, rgb: [247, 112, 92] },
          { index: 0.7059, rgb: [247, 114, 92] },
          { index: 0.7098, rgb: [248, 116, 92] },
          { index: 0.7137, rgb: [248, 118, 92] },
          { index: 0.7176, rgb: [249, 120, 93] },
          { index: 0.7216, rgb: [249, 121, 93] },
          { index: 0.7255, rgb: [249, 123, 93] },
          { index: 0.7294, rgb: [250, 125, 94] },
          { index: 0.7333, rgb: [250, 127, 94] },
          { index: 0.7373, rgb: [250, 129, 95] },
          { index: 0.7412, rgb: [251, 131, 95] },
          { index: 0.7451, rgb: [251, 133, 96] },
          { index: 0.749, rgb: [251, 135, 97] },
          { index: 0.7529, rgb: [252, 137, 97] },
          { index: 0.7569, rgb: [252, 138, 98] },
          { index: 0.7608, rgb: [252, 140, 99] },
          { index: 0.7647, rgb: [252, 142, 100] },
          { index: 0.7686, rgb: [252, 144, 101] },
          { index: 0.7725, rgb: [253, 146, 102] },
          { index: 0.7765, rgb: [253, 148, 103] },
          { index: 0.7804, rgb: [253, 150, 104] },
          { index: 0.7843, rgb: [253, 152, 105] },
          { index: 0.7882, rgb: [253, 154, 106] },
          { index: 0.7922, rgb: [253, 155, 107] },
          { index: 0.7961, rgb: [254, 157, 108] },
          { index: 0.8, rgb: [254, 159, 109] },
          { index: 0.8039, rgb: [254, 161, 110] },
          { index: 0.8078, rgb: [254, 163, 111] },
          { index: 0.8118, rgb: [254, 165, 113] },
          { index: 0.8157, rgb: [254, 167, 114] },
          { index: 0.8196, rgb: [254, 169, 115] },
          { index: 0.8235, rgb: [254, 170, 116] },
          { index: 0.8275, rgb: [254, 172, 118] },
          { index: 0.8314, rgb: [254, 174, 119] },
          { index: 0.8353, rgb: [254, 176, 120] },
          { index: 0.8392, rgb: [254, 178, 122] },
          { index: 0.8431, rgb: [254, 180, 123] },
          { index: 0.8471, rgb: [254, 182, 124] },
          { index: 0.851, rgb: [254, 183, 126] },
          { index: 0.8549, rgb: [254, 185, 127] },
          { index: 0.8588, rgb: [254, 187, 129] },
          { index: 0.8627, rgb: [254, 189, 130] },
          { index: 0.8667, rgb: [254, 191, 132] },
          { index: 0.8706, rgb: [254, 193, 133] },
          { index: 0.8745, rgb: [254, 194, 135] },
          { index: 0.8784, rgb: [254, 196, 136] },
          { index: 0.8824, rgb: [254, 198, 138] },
          { index: 0.8863, rgb: [254, 200, 140] },
          { index: 0.8902, rgb: [254, 202, 141] },
          { index: 0.8941, rgb: [254, 204, 143] },
          { index: 0.898, rgb: [254, 205, 144] },
          { index: 0.902, rgb: [254, 207, 146] },
          { index: 0.9059, rgb: [254, 209, 148] },
          { index: 0.9098, rgb: [254, 211, 149] },
          { index: 0.9137, rgb: [254, 213, 151] },
          { index: 0.9176, rgb: [254, 215, 153] },
          { index: 0.9216, rgb: [254, 216, 154] },
          { index: 0.9255, rgb: [253, 218, 156] },
          { index: 0.9294, rgb: [253, 220, 158] },
          { index: 0.9333, rgb: [253, 222, 160] },
          { index: 0.9373, rgb: [253, 224, 161] },
          { index: 0.9412, rgb: [253, 226, 163] },
          { index: 0.9451, rgb: [253, 227, 165] },
          { index: 0.949, rgb: [253, 229, 167] },
          { index: 0.9529, rgb: [253, 231, 169] },
          { index: 0.9569, rgb: [253, 233, 170] },
          { index: 0.9608, rgb: [253, 235, 172] },
          { index: 0.9647, rgb: [252, 236, 174] },
          { index: 0.9686, rgb: [252, 238, 176] },
          { index: 0.9725, rgb: [252, 240, 178] },
          { index: 0.9765, rgb: [252, 242, 180] },
          { index: 0.9804, rgb: [252, 244, 182] },
          { index: 0.9843, rgb: [252, 246, 184] },
          { index: 0.9882, rgb: [252, 247, 185] },
          { index: 0.9922, rgb: [252, 249, 187] },
          { index: 0.9961, rgb: [252, 251, 189] },
          { index: 1, rgb: [252, 253, 191] }
        ];
      },
      { colormap: 2 }
    ],
    6: [
      function (require, module, exports) {
        (function (global) {
          /*!
           * The buffer module from node.js, for the browser.
           *
           * @author   Feross Aboukhadijeh <feross@feross.org> <http://feross.org>
           * @license  MIT
           */

          const base64 = require('base64-js');
          const ieee754 = require('ieee754');
          const isArray = require('isarray');
          exports.Buffer = Buffer;
          exports.SlowBuffer = SlowBuffer;
          exports.INSPECT_MAX_BYTES = 50;
          Buffer.TYPED_ARRAY_SUPPORT =
            global.TYPED_ARRAY_SUPPORT !== undefined
              ? global.TYPED_ARRAY_SUPPORT
              : typedArraySupport();
          exports.kMaxLength = kMaxLength();
          function typedArraySupport() {
            try {
              const arr = new Uint8Array(1);
              arr.foo = function () {
                return 42;
              };
              return (
                arr.foo() === 42 &&
                typeof arr.subarray === 'function' &&
                arr.subarray(1, 1).byteLength === 0
              );
            } catch (e) {
              return false;
            }
          }
          function kMaxLength() {
            return Buffer.TYPED_ARRAY_SUPPORT ? 2147483647 : 1073741823;
          }
          function createBuffer(that, length) {
            if (kMaxLength() < length) {
              throw new RangeError('Invalid typed array length');
            }
            if (Buffer.TYPED_ARRAY_SUPPORT) {
              that = new Uint8Array(length);
              that.__proto__ = Buffer.prototype;
            } else {
              if (that === null) {
                that = new Buffer(length);
              }
              that.length = length;
            }
            return that;
          }
          function Buffer(arg, encodingOrOffset, length) {
            if (!Buffer.TYPED_ARRAY_SUPPORT && !(this instanceof Buffer)) {
              return new Buffer(arg, encodingOrOffset, length);
            }
            if (typeof arg === 'number') {
              if (typeof encodingOrOffset === 'string') {
                throw new Error(
                  'If encoding is specified then the first argument must be a string'
                );
              }
              return allocUnsafe(this, arg);
            }
            return from(this, arg, encodingOrOffset, length);
          }
          Buffer.poolSize = 8192;
          Buffer._augment = function (arr) {
            arr.__proto__ = Buffer.prototype;
            return arr;
          };
          function from(that, value, encodingOrOffset, length) {
            if (typeof value === 'number') {
              throw new TypeError('"value" argument must not be a number');
            }
            if (typeof ArrayBuffer !== 'undefined' && value instanceof ArrayBuffer) {
              return fromArrayBuffer(that, value, encodingOrOffset, length);
            }
            if (typeof value === 'string') {
              return fromString(that, value, encodingOrOffset);
            }
            return fromObject(that, value);
          }
          Buffer.from = function (value, encodingOrOffset, length) {
            return from(null, value, encodingOrOffset, length);
          };
          if (Buffer.TYPED_ARRAY_SUPPORT) {
            Buffer.prototype.__proto__ = Uint8Array.prototype;
            Buffer.__proto__ = Uint8Array;
            if (
              typeof Symbol !== 'undefined' &&
              Symbol.species &&
              Buffer[Symbol.species] === Buffer
            ) {
              Object.defineProperty(Buffer, Symbol.species, { value: null, configurable: true });
            }
          }
          function assertSize(size) {
            if (typeof size !== 'number') {
              throw new TypeError('"size" argument must be a number');
            }
          }
          function alloc(that, size, fill, encoding) {
            assertSize(size);
            if (size <= 0) {
              return createBuffer(that, size);
            }
            if (fill !== undefined) {
              return typeof encoding === 'string'
                ? createBuffer(that, size).fill(fill, encoding)
                : createBuffer(that, size).fill(fill);
            }
            return createBuffer(that, size);
          }
          Buffer.alloc = function (size, fill, encoding) {
            return alloc(null, size, fill, encoding);
          };
          function allocUnsafe(that, size) {
            assertSize(size);
            that = createBuffer(that, size < 0 ? 0 : checked(size) | 0);
            if (!Buffer.TYPED_ARRAY_SUPPORT) {
              for (let i = 0; i < size; i++) {
                that[i] = 0;
              }
            }
            return that;
          }
          Buffer.allocUnsafe = function (size) {
            return allocUnsafe(null, size);
          };
          Buffer.allocUnsafeSlow = function (size) {
            return allocUnsafe(null, size);
          };
          function fromString(that, string, encoding) {
            if (typeof encoding !== 'string' || encoding === '') {
              encoding = 'utf8';
            }
            if (!Buffer.isEncoding(encoding)) {
              throw new TypeError('"encoding" must be a valid string encoding');
            }
            const length = byteLength(string, encoding) | 0;
            that = createBuffer(that, length);
            that.write(string, encoding);
            return that;
          }
          function fromArrayLike(that, array) {
            const length = checked(array.length) | 0;
            that = createBuffer(that, length);
            for (let i = 0; i < length; i += 1) {
              that[i] = array[i] & 255;
            }
            return that;
          }
          function fromArrayBuffer(that, array, byteOffset, length) {
            array.byteLength;
            if (byteOffset < 0 || array.byteLength < byteOffset) {
              throw new RangeError("'offset' is out of bounds");
            }
            if (array.byteLength < byteOffset + (length || 0)) {
              throw new RangeError("'length' is out of bounds");
            }
            if (length === undefined) {
              array = new Uint8Array(array, byteOffset);
            } else {
              array = new Uint8Array(array, byteOffset, length);
            }
            if (Buffer.TYPED_ARRAY_SUPPORT) {
              that = array;
              that.__proto__ = Buffer.prototype;
            } else {
              that = fromArrayLike(that, array);
            }
            return that;
          }
          function fromObject(that, obj) {
            if (Buffer.isBuffer(obj)) {
              const len = checked(obj.length) | 0;
              that = createBuffer(that, len);
              if (that.length === 0) {
                return that;
              }
              obj.copy(that, 0, 0, len);
              return that;
            }
            if (obj) {
              if (
                (typeof ArrayBuffer !== 'undefined' && obj.buffer instanceof ArrayBuffer) ||
                'length' in obj
              ) {
                if (typeof obj.length !== 'number' || isnan(obj.length)) {
                  return createBuffer(that, 0);
                }
                return fromArrayLike(that, obj);
              }
              if (obj.type === 'Buffer' && isArray(obj.data)) {
                return fromArrayLike(that, obj.data);
              }
            }
            throw new TypeError(
              'First argument must be a string, Buffer, ArrayBuffer, Array, or array-like object.'
            );
          }
          function checked(length) {
            if (length >= kMaxLength()) {
              throw new RangeError(
                `${
                  'Attempt to allocate Buffer larger than maximum ' + 'size: 0x'
                }${kMaxLength().toString(16)} bytes`
              );
            }
            return length | 0;
          }
          function SlowBuffer(length) {
            if (+length != length) {
              length = 0;
            }
            return Buffer.alloc(+length);
          }
          Buffer.isBuffer = function isBuffer(b) {
            return !!(b != null && b._isBuffer);
          };
          Buffer.compare = function compare(a, b) {
            if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b)) {
              throw new TypeError('Arguments must be Buffers');
            }
            if (a === b) return 0;
            let x = a.length;
            let y = b.length;
            for (let i = 0, len = Math.min(x, y); i < len; ++i) {
              if (a[i] !== b[i]) {
                x = a[i];
                y = b[i];
                break;
              }
            }
            if (x < y) return -1;
            if (y < x) return 1;
            return 0;
          };
          Buffer.isEncoding = function isEncoding(encoding) {
            switch (String(encoding).toLowerCase()) {
              case 'hex':
              case 'utf8':
              case 'utf-8':
              case 'ascii':
              case 'binary':
              case 'base64':
              case 'raw':
              case 'ucs2':
              case 'ucs-2':
              case 'utf16le':
              case 'utf-16le':
                return true;
              default:
                return false;
            }
          };
          Buffer.concat = function concat(list, length) {
            if (!isArray(list)) {
              throw new TypeError('"list" argument must be an Array of Buffers');
            }
            if (list.length === 0) {
              return Buffer.alloc(0);
            }
            let i;
            if (length === undefined) {
              length = 0;
              for (i = 0; i < list.length; i++) {
                length += list[i].length;
              }
            }
            const buffer = Buffer.allocUnsafe(length);
            let pos = 0;
            for (i = 0; i < list.length; i++) {
              const buf = list[i];
              if (!Buffer.isBuffer(buf)) {
                throw new TypeError('"list" argument must be an Array of Buffers');
              }
              buf.copy(buffer, pos);
              pos += buf.length;
            }
            return buffer;
          };
          function byteLength(string, encoding) {
            if (Buffer.isBuffer(string)) {
              return string.length;
            }
            if (
              typeof ArrayBuffer !== 'undefined' &&
              typeof ArrayBuffer.isView === 'function' &&
              (ArrayBuffer.isView(string) || string instanceof ArrayBuffer)
            ) {
              return string.byteLength;
            }
            if (typeof string !== 'string') {
              string = `${string}`;
            }
            const len = string.length;
            if (len === 0) return 0;
            let loweredCase = false;
            for (;;) {
              switch (encoding) {
                case 'ascii':
                case 'binary':
                case 'raw':
                case 'raws':
                  return len;
                case 'utf8':
                case 'utf-8':
                case undefined:
                  return utf8ToBytes(string).length;
                case 'ucs2':
                case 'ucs-2':
                case 'utf16le':
                case 'utf-16le':
                  return len * 2;
                case 'hex':
                  return len >>> 1;
                case 'base64':
                  return base64ToBytes(string).length;
                default:
                  if (loweredCase) return utf8ToBytes(string).length;
                  encoding = `${encoding}`.toLowerCase();
                  loweredCase = true;
              }
            }
          }
          Buffer.byteLength = byteLength;
          function slowToString(encoding, start, end) {
            let loweredCase = false;
            if (start === undefined || start < 0) {
              start = 0;
            }
            if (start > this.length) {
              return '';
            }
            if (end === undefined || end > this.length) {
              end = this.length;
            }
            if (end <= 0) {
              return '';
            }
            end >>>= 0;
            start >>>= 0;
            if (end <= start) {
              return '';
            }
            if (!encoding) encoding = 'utf8';
            while (true) {
              switch (encoding) {
                case 'hex':
                  return hexSlice(this, start, end);
                case 'utf8':
                case 'utf-8':
                  return utf8Slice(this, start, end);
                case 'ascii':
                  return asciiSlice(this, start, end);
                case 'binary':
                  return binarySlice(this, start, end);
                case 'base64':
                  return base64Slice(this, start, end);
                case 'ucs2':
                case 'ucs-2':
                case 'utf16le':
                case 'utf-16le':
                  return utf16leSlice(this, start, end);
                default:
                  if (loweredCase) throw new TypeError(`Unknown encoding: ${encoding}`);
                  encoding = `${encoding}`.toLowerCase();
                  loweredCase = true;
              }
            }
          }
          Buffer.prototype._isBuffer = true;
          function swap(b, n, m) {
            const i = b[n];
            b[n] = b[m];
            b[m] = i;
          }
          Buffer.prototype.swap16 = function swap16() {
            const len = this.length;
            if (len % 2 !== 0) {
              throw new RangeError('Buffer size must be a multiple of 16-bits');
            }
            for (let i = 0; i < len; i += 2) {
              swap(this, i, i + 1);
            }
            return this;
          };
          Buffer.prototype.swap32 = function swap32() {
            const len = this.length;
            if (len % 4 !== 0) {
              throw new RangeError('Buffer size must be a multiple of 32-bits');
            }
            for (let i = 0; i < len; i += 4) {
              swap(this, i, i + 3);
              swap(this, i + 1, i + 2);
            }
            return this;
          };
          Buffer.prototype.toString = function toString() {
            const length = this.length | 0;
            if (length === 0) return '';
            if (arguments.length === 0) return utf8Slice(this, 0, length);
            return slowToString.apply(this, arguments);
          };
          Buffer.prototype.equals = function equals(b) {
            if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer');
            if (this === b) return true;
            return Buffer.compare(this, b) === 0;
          };
          Buffer.prototype.inspect = function inspect() {
            let str = '';
            const max = exports.INSPECT_MAX_BYTES;
            if (this.length > 0) {
              str = this.toString('hex', 0, max).match(/.{2}/g).join(' ');
              if (this.length > max) str += ' ... ';
            }
            return `<Buffer ${str}>`;
          };
          Buffer.prototype.compare = function compare(target, start, end, thisStart, thisEnd) {
            if (!Buffer.isBuffer(target)) {
              throw new TypeError('Argument must be a Buffer');
            }
            if (start === undefined) {
              start = 0;
            }
            if (end === undefined) {
              end = target ? target.length : 0;
            }
            if (thisStart === undefined) {
              thisStart = 0;
            }
            if (thisEnd === undefined) {
              thisEnd = this.length;
            }
            if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {
              throw new RangeError('out of range index');
            }
            if (thisStart >= thisEnd && start >= end) {
              return 0;
            }
            if (thisStart >= thisEnd) {
              return -1;
            }
            if (start >= end) {
              return 1;
            }
            start >>>= 0;
            end >>>= 0;
            thisStart >>>= 0;
            thisEnd >>>= 0;
            if (this === target) return 0;
            let x = thisEnd - thisStart;
            let y = end - start;
            const len = Math.min(x, y);
            const thisCopy = this.slice(thisStart, thisEnd);
            const targetCopy = target.slice(start, end);
            for (let i = 0; i < len; ++i) {
              if (thisCopy[i] !== targetCopy[i]) {
                x = thisCopy[i];
                y = targetCopy[i];
                break;
              }
            }
            if (x < y) return -1;
            if (y < x) return 1;
            return 0;
          };
          function arrayIndexOf(arr, val, byteOffset, encoding) {
            let indexSize = 1;
            let arrLength = arr.length;
            let valLength = val.length;
            if (encoding !== undefined) {
              encoding = String(encoding).toLowerCase();
              if (
                encoding === 'ucs2' ||
                encoding === 'ucs-2' ||
                encoding === 'utf16le' ||
                encoding === 'utf-16le'
              ) {
                if (arr.length < 2 || val.length < 2) {
                  return -1;
                }
                indexSize = 2;
                arrLength /= 2;
                valLength /= 2;
                byteOffset /= 2;
              }
            }
            function read(buf, i) {
              if (indexSize === 1) {
                return buf[i];
              }
              return buf.readUInt16BE(i * indexSize);
            }
            let foundIndex = -1;
            for (let i = 0; byteOffset + i < arrLength; i++) {
              if (read(arr, byteOffset + i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {
                if (foundIndex === -1) foundIndex = i;
                if (i - foundIndex + 1 === valLength) return (byteOffset + foundIndex) * indexSize;
              } else {
                if (foundIndex !== -1) i -= i - foundIndex;
                foundIndex = -1;
              }
            }
            return -1;
          }
          Buffer.prototype.indexOf = function indexOf(val, byteOffset, encoding) {
            if (typeof byteOffset === 'string') {
              encoding = byteOffset;
              byteOffset = 0;
            } else if (byteOffset > 2147483647) {
              byteOffset = 2147483647;
            } else if (byteOffset < -2147483648) {
              byteOffset = -2147483648;
            }
            byteOffset >>= 0;
            if (this.length === 0) return -1;
            if (byteOffset >= this.length) return -1;
            if (byteOffset < 0) byteOffset = Math.max(this.length + byteOffset, 0);
            if (typeof val === 'string') {
              val = Buffer.from(val, encoding);
            }
            if (Buffer.isBuffer(val)) {
              if (val.length === 0) {
                return -1;
              }
              return arrayIndexOf(this, val, byteOffset, encoding);
            }
            if (typeof val === 'number') {
              if (Buffer.TYPED_ARRAY_SUPPORT && Uint8Array.prototype.indexOf === 'function') {
                return Uint8Array.prototype.indexOf.call(this, val, byteOffset);
              }
              return arrayIndexOf(this, [val], byteOffset, encoding);
            }
            throw new TypeError('val must be string, number or Buffer');
          };
          Buffer.prototype.includes = function includes(val, byteOffset, encoding) {
            return this.indexOf(val, byteOffset, encoding) !== -1;
          };
          function hexWrite(buf, string, offset, length) {
            offset = Number(offset) || 0;
            const remaining = buf.length - offset;
            if (!length) {
              length = remaining;
            } else {
              length = Number(length);
              if (length > remaining) {
                length = remaining;
              }
            }
            const strLen = string.length;
            if (strLen % 2 !== 0) throw new Error('Invalid hex string');
            if (length > strLen / 2) {
              length = strLen / 2;
            }
            for (var i = 0; i < length; i++) {
              const parsed = parseInt(string.substr(i * 2, 2), 16);
              if (isNaN(parsed)) return i;
              buf[offset + i] = parsed;
            }
            return i;
          }
          function utf8Write(buf, string, offset, length) {
            return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length);
          }
          function asciiWrite(buf, string, offset, length) {
            return blitBuffer(asciiToBytes(string), buf, offset, length);
          }
          function binaryWrite(buf, string, offset, length) {
            return asciiWrite(buf, string, offset, length);
          }
          function base64Write(buf, string, offset, length) {
            return blitBuffer(base64ToBytes(string), buf, offset, length);
          }
          function ucs2Write(buf, string, offset, length) {
            return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length);
          }
          Buffer.prototype.write = function write(string, offset, length, encoding) {
            if (offset === undefined) {
              encoding = 'utf8';
              length = this.length;
              offset = 0;
            } else if (length === undefined && typeof offset === 'string') {
              encoding = offset;
              length = this.length;
              offset = 0;
            } else if (isFinite(offset)) {
              offset |= 0;
              if (isFinite(length)) {
                length |= 0;
                if (encoding === undefined) encoding = 'utf8';
              } else {
                encoding = length;
                length = undefined;
              }
            } else {
              throw new Error(
                'Buffer.write(string, encoding, offset[, length]) is no longer supported'
              );
            }
            const remaining = this.length - offset;
            if (length === undefined || length > remaining) length = remaining;
            if ((string.length > 0 && (length < 0 || offset < 0)) || offset > this.length) {
              throw new RangeError('Attempt to write outside buffer bounds');
            }
            if (!encoding) encoding = 'utf8';
            let loweredCase = false;
            for (;;) {
              switch (encoding) {
                case 'hex':
                  return hexWrite(this, string, offset, length);
                case 'utf8':
                case 'utf-8':
                  return utf8Write(this, string, offset, length);
                case 'ascii':
                  return asciiWrite(this, string, offset, length);
                case 'binary':
                  return binaryWrite(this, string, offset, length);
                case 'base64':
                  return base64Write(this, string, offset, length);
                case 'ucs2':
                case 'ucs-2':
                case 'utf16le':
                case 'utf-16le':
                  return ucs2Write(this, string, offset, length);
                default:
                  if (loweredCase) throw new TypeError(`Unknown encoding: ${encoding}`);
                  encoding = `${encoding}`.toLowerCase();
                  loweredCase = true;
              }
            }
          };
          Buffer.prototype.toJSON = function toJSON() {
            return { type: 'Buffer', data: Array.prototype.slice.call(this._arr || this, 0) };
          };
          function base64Slice(buf, start, end) {
            if (start === 0 && end === buf.length) {
              return base64.fromByteArray(buf);
            }
            return base64.fromByteArray(buf.slice(start, end));
          }
          function utf8Slice(buf, start, end) {
            end = Math.min(buf.length, end);
            const res = [];
            let i = start;
            while (i < end) {
              const firstByte = buf[i];
              let codePoint = null;
              let bytesPerSequence =
                firstByte > 239 ? 4 : firstByte > 223 ? 3 : firstByte > 191 ? 2 : 1;
              if (i + bytesPerSequence <= end) {
                var secondByte;
                var thirdByte;
                var fourthByte;
                var tempCodePoint;
                switch (bytesPerSequence) {
                  case 1:
                    if (firstByte < 128) {
                      codePoint = firstByte;
                    }
                    break;
                  case 2:
                    secondByte = buf[i + 1];
                    if ((secondByte & 192) === 128) {
                      tempCodePoint = ((firstByte & 31) << 6) | (secondByte & 63);
                      if (tempCodePoint > 127) {
                        codePoint = tempCodePoint;
                      }
                    }
                    break;
                  case 3:
                    secondByte = buf[i + 1];
                    thirdByte = buf[i + 2];
                    if ((secondByte & 192) === 128 && (thirdByte & 192) === 128) {
                      tempCodePoint =
                        ((firstByte & 15) << 12) | ((secondByte & 63) << 6) | (thirdByte & 63);
                      if (
                        tempCodePoint > 2047 &&
                        (tempCodePoint < 55296 || tempCodePoint > 57343)
                      ) {
                        codePoint = tempCodePoint;
                      }
                    }
                    break;
                  case 4:
                    secondByte = buf[i + 1];
                    thirdByte = buf[i + 2];
                    fourthByte = buf[i + 3];
                    if (
                      (secondByte & 192) === 128 &&
                      (thirdByte & 192) === 128 &&
                      (fourthByte & 192) === 128
                    ) {
                      tempCodePoint =
                        ((firstByte & 15) << 18) |
                        ((secondByte & 63) << 12) |
                        ((thirdByte & 63) << 6) |
                        (fourthByte & 63);
                      if (tempCodePoint > 65535 && tempCodePoint < 1114112) {
                        codePoint = tempCodePoint;
                      }
                    }
                }
              }
              if (codePoint === null) {
                codePoint = 65533;
                bytesPerSequence = 1;
              } else if (codePoint > 65535) {
                codePoint -= 65536;
                res.push(((codePoint >>> 10) & 1023) | 55296);
                codePoint = 56320 | (codePoint & 1023);
              }
              res.push(codePoint);
              i += bytesPerSequence;
            }
            return decodeCodePointsArray(res);
          }
          const MAX_ARGUMENTS_LENGTH = 4096;
          function decodeCodePointsArray(codePoints) {
            const len = codePoints.length;
            if (len <= MAX_ARGUMENTS_LENGTH) {
              return String.fromCharCode.apply(String, codePoints);
            }
            let res = '';
            let i = 0;
            while (i < len) {
              res += String.fromCharCode.apply(
                String,
                codePoints.slice(i, (i += MAX_ARGUMENTS_LENGTH))
              );
            }
            return res;
          }
          function asciiSlice(buf, start, end) {
            let ret = '';
            end = Math.min(buf.length, end);
            for (let i = start; i < end; i++) {
              ret += String.fromCharCode(buf[i] & 127);
            }
            return ret;
          }
          function binarySlice(buf, start, end) {
            let ret = '';
            end = Math.min(buf.length, end);
            for (let i = start; i < end; i++) {
              ret += String.fromCharCode(buf[i]);
            }
            return ret;
          }
          function hexSlice(buf, start, end) {
            const len = buf.length;
            if (!start || start < 0) start = 0;
            if (!end || end < 0 || end > len) end = len;
            let out = '';
            for (let i = start; i < end; i++) {
              out += toHex(buf[i]);
            }
            return out;
          }
          function utf16leSlice(buf, start, end) {
            const bytes = buf.slice(start, end);
            let res = '';
            for (let i = 0; i < bytes.length; i += 2) {
              res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256);
            }
            return res;
          }
          Buffer.prototype.slice = function slice(start, end) {
            const len = this.length;
            start = ~~start;
            end = end === undefined ? len : ~~end;
            if (start < 0) {
              start += len;
              if (start < 0) start = 0;
            } else if (start > len) {
              start = len;
            }
            if (end < 0) {
              end += len;
              if (end < 0) end = 0;
            } else if (end > len) {
              end = len;
            }
            if (end < start) end = start;
            let newBuf;
            if (Buffer.TYPED_ARRAY_SUPPORT) {
              newBuf = this.subarray(start, end);
              newBuf.__proto__ = Buffer.prototype;
            } else {
              const sliceLen = end - start;
              newBuf = new Buffer(sliceLen, undefined);
              for (let i = 0; i < sliceLen; i++) {
                newBuf[i] = this[i + start];
              }
            }
            return newBuf;
          };
          function checkOffset(offset, ext, length) {
            if (offset % 1 !== 0 || offset < 0) throw new RangeError('offset is not uint');
            if (offset + ext > length)
              throw new RangeError('Trying to access beyond buffer length');
          }
          Buffer.prototype.readUIntLE = function readUIntLE(offset, byteLength, noAssert) {
            offset |= 0;
            byteLength |= 0;
            if (!noAssert) checkOffset(offset, byteLength, this.length);
            let val = this[offset];
            let mul = 1;
            let i = 0;
            while (++i < byteLength && (mul *= 256)) {
              val += this[offset + i] * mul;
            }
            return val;
          };
          Buffer.prototype.readUIntBE = function readUIntBE(offset, byteLength, noAssert) {
            offset |= 0;
            byteLength |= 0;
            if (!noAssert) {
              checkOffset(offset, byteLength, this.length);
            }
            let val = this[offset + --byteLength];
            let mul = 1;
            while (byteLength > 0 && (mul *= 256)) {
              val += this[offset + --byteLength] * mul;
            }
            return val;
          };
          Buffer.prototype.readUInt8 = function readUInt8(offset, noAssert) {
            if (!noAssert) checkOffset(offset, 1, this.length);
            return this[offset];
          };
          Buffer.prototype.readUInt16LE = function readUInt16LE(offset, noAssert) {
            if (!noAssert) checkOffset(offset, 2, this.length);
            return this[offset] | (this[offset + 1] << 8);
          };
          Buffer.prototype.readUInt16BE = function readUInt16BE(offset, noAssert) {
            if (!noAssert) checkOffset(offset, 2, this.length);
            return (this[offset] << 8) | this[offset + 1];
          };
          Buffer.prototype.readUInt32LE = function readUInt32LE(offset, noAssert) {
            if (!noAssert) checkOffset(offset, 4, this.length);
            return (
              (this[offset] | (this[offset + 1] << 8) | (this[offset + 2] << 16)) +
              this[offset + 3] * 16777216
            );
          };
          Buffer.prototype.readUInt32BE = function readUInt32BE(offset, noAssert) {
            if (!noAssert) checkOffset(offset, 4, this.length);
            return (
              this[offset] * 16777216 +
              ((this[offset + 1] << 16) | (this[offset + 2] << 8) | this[offset + 3])
            );
          };
          Buffer.prototype.readIntLE = function readIntLE(offset, byteLength, noAssert) {
            offset |= 0;
            byteLength |= 0;
            if (!noAssert) checkOffset(offset, byteLength, this.length);
            let val = this[offset];
            let mul = 1;
            let i = 0;
            while (++i < byteLength && (mul *= 256)) {
              val += this[offset + i] * mul;
            }
            mul *= 128;
            if (val >= mul) val -= Math.pow(2, 8 * byteLength);
            return val;
          };
          Buffer.prototype.readIntBE = function readIntBE(offset, byteLength, noAssert) {
            offset |= 0;
            byteLength |= 0;
            if (!noAssert) checkOffset(offset, byteLength, this.length);
            let i = byteLength;
            let mul = 1;
            let val = this[offset + --i];
            while (i > 0 && (mul *= 256)) {
              val += this[offset + --i] * mul;
            }
            mul *= 128;
            if (val >= mul) val -= Math.pow(2, 8 * byteLength);
            return val;
          };
          Buffer.prototype.readInt8 = function readInt8(offset, noAssert) {
            if (!noAssert) checkOffset(offset, 1, this.length);
            if (!(this[offset] & 128)) return this[offset];
            return (255 - this[offset] + 1) * -1;
          };
          Buffer.prototype.readInt16LE = function readInt16LE(offset, noAssert) {
            if (!noAssert) checkOffset(offset, 2, this.length);
            const val = this[offset] | (this[offset + 1] << 8);
            return val & 32768 ? val | 4294901760 : val;
          };
          Buffer.prototype.readInt16BE = function readInt16BE(offset, noAssert) {
            if (!noAssert) checkOffset(offset, 2, this.length);
            const val = this[offset + 1] | (this[offset] << 8);
            return val & 32768 ? val | 4294901760 : val;
          };
          Buffer.prototype.readInt32LE = function readInt32LE(offset, noAssert) {
            if (!noAssert) checkOffset(offset, 4, this.length);
            return (
              this[offset] |
              (this[offset + 1] << 8) |
              (this[offset + 2] << 16) |
              (this[offset + 3] << 24)
            );
          };
          Buffer.prototype.readInt32BE = function readInt32BE(offset, noAssert) {
            if (!noAssert) checkOffset(offset, 4, this.length);
            return (
              (this[offset] << 24) |
              (this[offset + 1] << 16) |
              (this[offset + 2] << 8) |
              this[offset + 3]
            );
          };
          Buffer.prototype.readFloatLE = function readFloatLE(offset, noAssert) {
            if (!noAssert) checkOffset(offset, 4, this.length);
            return ieee754.read(this, offset, true, 23, 4);
          };
          Buffer.prototype.readFloatBE = function readFloatBE(offset, noAssert) {
            if (!noAssert) checkOffset(offset, 4, this.length);
            return ieee754.read(this, offset, false, 23, 4);
          };
          Buffer.prototype.readDoubleLE = function readDoubleLE(offset, noAssert) {
            if (!noAssert) checkOffset(offset, 8, this.length);
            return ieee754.read(this, offset, true, 52, 8);
          };
          Buffer.prototype.readDoubleBE = function readDoubleBE(offset, noAssert) {
            if (!noAssert) checkOffset(offset, 8, this.length);
            return ieee754.read(this, offset, false, 52, 8);
          };
          function checkInt(buf, value, offset, ext, max, min) {
            if (!Buffer.isBuffer(buf))
              throw new TypeError('"buffer" argument must be a Buffer instance');
            if (value > max || value < min)
              throw new RangeError('"value" argument is out of bounds');
            if (offset + ext > buf.length) throw new RangeError('Index out of range');
          }
          Buffer.prototype.writeUIntLE = function writeUIntLE(value, offset, byteLength, noAssert) {
            value = +value;
            offset |= 0;
            byteLength |= 0;
            if (!noAssert) {
              const maxBytes = Math.pow(2, 8 * byteLength) - 1;
              checkInt(this, value, offset, byteLength, maxBytes, 0);
            }
            let mul = 1;
            let i = 0;
            this[offset] = value & 255;
            while (++i < byteLength && (mul *= 256)) {
              this[offset + i] = (value / mul) & 255;
            }
            return offset + byteLength;
          };
          Buffer.prototype.writeUIntBE = function writeUIntBE(value, offset, byteLength, noAssert) {
            value = +value;
            offset |= 0;
            byteLength |= 0;
            if (!noAssert) {
              const maxBytes = Math.pow(2, 8 * byteLength) - 1;
              checkInt(this, value, offset, byteLength, maxBytes, 0);
            }
            let i = byteLength - 1;
            let mul = 1;
            this[offset + i] = value & 255;
            while (--i >= 0 && (mul *= 256)) {
              this[offset + i] = (value / mul) & 255;
            }
            return offset + byteLength;
          };
          Buffer.prototype.writeUInt8 = function writeUInt8(value, offset, noAssert) {
            value = +value;
            offset |= 0;
            if (!noAssert) checkInt(this, value, offset, 1, 255, 0);
            if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value);
            this[offset] = value & 255;
            return offset + 1;
          };
          function objectWriteUInt16(buf, value, offset, littleEndian) {
            if (value < 0) value = 65535 + value + 1;
            for (let i = 0, j = Math.min(buf.length - offset, 2); i < j; i++) {
              buf[offset + i] =
                (value & (255 << (8 * (littleEndian ? i : 1 - i)))) >>>
                ((littleEndian ? i : 1 - i) * 8);
            }
          }
          Buffer.prototype.writeUInt16LE = function writeUInt16LE(value, offset, noAssert) {
            value = +value;
            offset |= 0;
            if (!noAssert) checkInt(this, value, offset, 2, 65535, 0);
            if (Buffer.TYPED_ARRAY_SUPPORT) {
              this[offset] = value & 255;
              this[offset + 1] = value >>> 8;
            } else {
              objectWriteUInt16(this, value, offset, true);
            }
            return offset + 2;
          };
          Buffer.prototype.writeUInt16BE = function writeUInt16BE(value, offset, noAssert) {
            value = +value;
            offset |= 0;
            if (!noAssert) checkInt(this, value, offset, 2, 65535, 0);
            if (Buffer.TYPED_ARRAY_SUPPORT) {
              this[offset] = value >>> 8;
              this[offset + 1] = value & 255;
            } else {
              objectWriteUInt16(this, value, offset, false);
            }
            return offset + 2;
          };
          function objectWriteUInt32(buf, value, offset, littleEndian) {
            if (value < 0) value = 4294967295 + value + 1;
            for (let i = 0, j = Math.min(buf.length - offset, 4); i < j; i++) {
              buf[offset + i] = (value >>> ((littleEndian ? i : 3 - i) * 8)) & 255;
            }
          }
          Buffer.prototype.writeUInt32LE = function writeUInt32LE(value, offset, noAssert) {
            value = +value;
            offset |= 0;
            if (!noAssert) checkInt(this, value, offset, 4, 4294967295, 0);
            if (Buffer.TYPED_ARRAY_SUPPORT) {
              this[offset + 3] = value >>> 24;
              this[offset + 2] = value >>> 16;
              this[offset + 1] = value >>> 8;
              this[offset] = value & 255;
            } else {
              objectWriteUInt32(this, value, offset, true);
            }
            return offset + 4;
          };
          Buffer.prototype.writeUInt32BE = function writeUInt32BE(value, offset, noAssert) {
            value = +value;
            offset |= 0;
            if (!noAssert) checkInt(this, value, offset, 4, 4294967295, 0);
            if (Buffer.TYPED_ARRAY_SUPPORT) {
              this[offset] = value >>> 24;
              this[offset + 1] = value >>> 16;
              this[offset + 2] = value >>> 8;
              this[offset + 3] = value & 255;
            } else {
              objectWriteUInt32(this, value, offset, false);
            }
            return offset + 4;
          };
          Buffer.prototype.writeIntLE = function writeIntLE(value, offset, byteLength, noAssert) {
            value = +value;
            offset |= 0;
            if (!noAssert) {
              const limit = Math.pow(2, 8 * byteLength - 1);
              checkInt(this, value, offset, byteLength, limit - 1, -limit);
            }
            let i = 0;
            let mul = 1;
            let sub = 0;
            this[offset] = value & 255;
            while (++i < byteLength && (mul *= 256)) {
              if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {
                sub = 1;
              }
              this[offset + i] = (((value / mul) >> 0) - sub) & 255;
            }
            return offset + byteLength;
          };
          Buffer.prototype.writeIntBE = function writeIntBE(value, offset, byteLength, noAssert) {
            value = +value;
            offset |= 0;
            if (!noAssert) {
              const limit = Math.pow(2, 8 * byteLength - 1);
              checkInt(this, value, offset, byteLength, limit - 1, -limit);
            }
            let i = byteLength - 1;
            let mul = 1;
            let sub = 0;
            this[offset + i] = value & 255;
            while (--i >= 0 && (mul *= 256)) {
              if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {
                sub = 1;
              }
              this[offset + i] = (((value / mul) >> 0) - sub) & 255;
            }
            return offset + byteLength;
          };
          Buffer.prototype.writeInt8 = function writeInt8(value, offset, noAssert) {
            value = +value;
            offset |= 0;
            if (!noAssert) checkInt(this, value, offset, 1, 127, -128);
            if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value);
            if (value < 0) value = 255 + value + 1;
            this[offset] = value & 255;
            return offset + 1;
          };
          Buffer.prototype.writeInt16LE = function writeInt16LE(value, offset, noAssert) {
            value = +value;
            offset |= 0;
            if (!noAssert) checkInt(this, value, offset, 2, 32767, -32768);
            if (Buffer.TYPED_ARRAY_SUPPORT) {
              this[offset] = value & 255;
              this[offset + 1] = value >>> 8;
            } else {
              objectWriteUInt16(this, value, offset, true);
            }
            return offset + 2;
          };
          Buffer.prototype.writeInt16BE = function writeInt16BE(value, offset, noAssert) {
            value = +value;
            offset |= 0;
            if (!noAssert) checkInt(this, value, offset, 2, 32767, -32768);
            if (Buffer.TYPED_ARRAY_SUPPORT) {
              this[offset] = value >>> 8;
              this[offset + 1] = value & 255;
            } else {
              objectWriteUInt16(this, value, offset, false);
            }
            return offset + 2;
          };
          Buffer.prototype.writeInt32LE = function writeInt32LE(value, offset, noAssert) {
            value = +value;
            offset |= 0;
            if (!noAssert) checkInt(this, value, offset, 4, 2147483647, -2147483648);
            if (Buffer.TYPED_ARRAY_SUPPORT) {
              this[offset] = value & 255;
              this[offset + 1] = value >>> 8;
              this[offset + 2] = value >>> 16;
              this[offset + 3] = value >>> 24;
            } else {
              objectWriteUInt32(this, value, offset, true);
            }
            return offset + 4;
          };
          Buffer.prototype.writeInt32BE = function writeInt32BE(value, offset, noAssert) {
            value = +value;
            offset |= 0;
            if (!noAssert) checkInt(this, value, offset, 4, 2147483647, -2147483648);
            if (value < 0) value = 4294967295 + value + 1;
            if (Buffer.TYPED_ARRAY_SUPPORT) {
              this[offset] = value >>> 24;
              this[offset + 1] = value >>> 16;
              this[offset + 2] = value >>> 8;
              this[offset + 3] = value & 255;
            } else {
              objectWriteUInt32(this, value, offset, false);
            }
            return offset + 4;
          };
          function checkIEEE754(buf, value, offset, ext, max, min) {
            if (offset + ext > buf.length) throw new RangeError('Index out of range');
            if (offset < 0) throw new RangeError('Index out of range');
          }
          function writeFloat(buf, value, offset, littleEndian, noAssert) {
            if (!noAssert) {
              checkIEEE754(buf, value, offset, 4, 3.4028234663852886e38, -3.4028234663852886e38);
            }
            ieee754.write(buf, value, offset, littleEndian, 23, 4);
            return offset + 4;
          }
          Buffer.prototype.writeFloatLE = function writeFloatLE(value, offset, noAssert) {
            return writeFloat(this, value, offset, true, noAssert);
          };
          Buffer.prototype.writeFloatBE = function writeFloatBE(value, offset, noAssert) {
            return writeFloat(this, value, offset, false, noAssert);
          };
          function writeDouble(buf, value, offset, littleEndian, noAssert) {
            if (!noAssert) {
              checkIEEE754(buf, value, offset, 8, 1.7976931348623157e308, -1.7976931348623157e308);
            }
            ieee754.write(buf, value, offset, littleEndian, 52, 8);
            return offset + 8;
          }
          Buffer.prototype.writeDoubleLE = function writeDoubleLE(value, offset, noAssert) {
            return writeDouble(this, value, offset, true, noAssert);
          };
          Buffer.prototype.writeDoubleBE = function writeDoubleBE(value, offset, noAssert) {
            return writeDouble(this, value, offset, false, noAssert);
          };
          Buffer.prototype.copy = function copy(target, targetStart, start, end) {
            if (!start) start = 0;
            if (!end && end !== 0) end = this.length;
            if (targetStart >= target.length) targetStart = target.length;
            if (!targetStart) targetStart = 0;
            if (end > 0 && end < start) end = start;
            if (end === start) return 0;
            if (target.length === 0 || this.length === 0) return 0;
            if (targetStart < 0) {
              throw new RangeError('targetStart out of bounds');
            }
            if (start < 0 || start >= this.length)
              throw new RangeError('sourceStart out of bounds');
            if (end < 0) throw new RangeError('sourceEnd out of bounds');
            if (end > this.length) end = this.length;
            if (target.length - targetStart < end - start) {
              end = target.length - targetStart + start;
            }
            const len = end - start;
            let i;
            if (this === target && start < targetStart && targetStart < end) {
              for (i = len - 1; i >= 0; i--) {
                target[i + targetStart] = this[i + start];
              }
            } else if (len < 1e3 || !Buffer.TYPED_ARRAY_SUPPORT) {
              for (i = 0; i < len; i++) {
                target[i + targetStart] = this[i + start];
              }
            } else {
              Uint8Array.prototype.set.call(target, this.subarray(start, start + len), targetStart);
            }
            return len;
          };
          Buffer.prototype.fill = function fill(val, start, end, encoding) {
            if (typeof val === 'string') {
              if (typeof start === 'string') {
                encoding = start;
                start = 0;
                end = this.length;
              } else if (typeof end === 'string') {
                encoding = end;
                end = this.length;
              }
              if (val.length === 1) {
                const code = val.charCodeAt(0);
                if (code < 256) {
                  val = code;
                }
              }
              if (encoding !== undefined && typeof encoding !== 'string') {
                throw new TypeError('encoding must be a string');
              }
              if (typeof encoding === 'string' && !Buffer.isEncoding(encoding)) {
                throw new TypeError(`Unknown encoding: ${encoding}`);
              }
            } else if (typeof val === 'number') {
              val &= 255;
            }
            if (start < 0 || this.length < start || this.length < end) {
              throw new RangeError('Out of range index');
            }
            if (end <= start) {
              return this;
            }
            start >>>= 0;
            end = end === undefined ? this.length : end >>> 0;
            if (!val) val = 0;
            let i;
            if (typeof val === 'number') {
              for (i = start; i < end; i++) {
                this[i] = val;
              }
            } else {
              const bytes = Buffer.isBuffer(val)
                ? val
                : utf8ToBytes(new Buffer(val, encoding).toString());
              const len = bytes.length;
              for (i = 0; i < end - start; i++) {
                this[i + start] = bytes[i % len];
              }
            }
            return this;
          };
          const INVALID_BASE64_RE = /[^+\/0-9A-Za-z-_]/g;
          function base64clean(str) {
            str = stringtrim(str).replace(INVALID_BASE64_RE, '');
            if (str.length < 2) return '';
            while (str.length % 4 !== 0) {
              str += '=';
            }
            return str;
          }
          function stringtrim(str) {
            if (str.trim) return str.trim();
            return str.replace(/^\s+|\s+$/g, '');
          }
          function toHex(n) {
            if (n < 16) return `0${n.toString(16)}`;
            return n.toString(16);
          }
          function utf8ToBytes(string, units) {
            units = units || Infinity;
            let codePoint;
            const { length } = string;
            let leadSurrogate = null;
            const bytes = [];
            for (let i = 0; i < length; i++) {
              codePoint = string.charCodeAt(i);
              if (codePoint > 55295 && codePoint < 57344) {
                if (!leadSurrogate) {
                  if (codePoint > 56319) {
                    if ((units -= 3) > -1) bytes.push(239, 191, 189);
                    continue;
                  } else if (i + 1 === length) {
                    if ((units -= 3) > -1) bytes.push(239, 191, 189);
                    continue;
                  }
                  leadSurrogate = codePoint;
                  continue;
                }
                if (codePoint < 56320) {
                  if ((units -= 3) > -1) bytes.push(239, 191, 189);
                  leadSurrogate = codePoint;
                  continue;
                }
                codePoint = (((leadSurrogate - 55296) << 10) | (codePoint - 56320)) + 65536;
              } else if (leadSurrogate) {
                if ((units -= 3) > -1) bytes.push(239, 191, 189);
              }
              leadSurrogate = null;
              if (codePoint < 128) {
                if ((units -= 1) < 0) break;
                bytes.push(codePoint);
              } else if (codePoint < 2048) {
                if ((units -= 2) < 0) break;
                bytes.push((codePoint >> 6) | 192, (codePoint & 63) | 128);
              } else if (codePoint < 65536) {
                if ((units -= 3) < 0) break;
                bytes.push(
                  (codePoint >> 12) | 224,
                  ((codePoint >> 6) & 63) | 128,
                  (codePoint & 63) | 128
                );
              } else if (codePoint < 1114112) {
                if ((units -= 4) < 0) break;
                bytes.push(
                  (codePoint >> 18) | 240,
                  ((codePoint >> 12) & 63) | 128,
                  ((codePoint >> 6) & 63) | 128,
                  (codePoint & 63) | 128
                );
              } else {
                throw new Error('Invalid code point');
              }
            }
            return bytes;
          }
          function asciiToBytes(str) {
            const byteArray = [];
            for (let i = 0; i < str.length; i++) {
              byteArray.push(str.charCodeAt(i) & 255);
            }
            return byteArray;
          }
          function utf16leToBytes(str, units) {
            let c;
            let hi;
            let lo;
            const byteArray = [];
            for (let i = 0; i < str.length; i++) {
              if ((units -= 2) < 0) break;
              c = str.charCodeAt(i);
              hi = c >> 8;
              lo = c % 256;
              byteArray.push(lo);
              byteArray.push(hi);
            }
            return byteArray;
          }
          function base64ToBytes(str) {
            return base64.toByteArray(base64clean(str));
          }
          function blitBuffer(src, dst, offset, length) {
            for (var i = 0; i < length; i++) {
              if (i + offset >= dst.length || i >= src.length) break;
              dst[i + offset] = src[i];
            }
            return i;
          }
          function isnan(val) {
            return val !== val;
          }
        }.call(
          this,
          typeof global !== 'undefined'
            ? global
            : typeof self !== 'undefined'
            ? self
            : typeof window !== 'undefined'
            ? window
            : {}
        ));
      },
      { 'base64-js': 7, ieee754: 8, isarray: 9 }
    ],
    7: [
      function (require, module, exports) {
        exports.toByteArray = toByteArray;
        exports.fromByteArray = fromByteArray;
        const lookup = [];
        const revLookup = [];
        const Arr = typeof Uint8Array !== 'undefined' ? Uint8Array : Array;
        function init() {
          const code = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';
          for (let i = 0, len = code.length; i < len; ++i) {
            lookup[i] = code[i];
            revLookup[code.charCodeAt(i)] = i;
          }
          revLookup['-'.charCodeAt(0)] = 62;
          revLookup['_'.charCodeAt(0)] = 63;
        }
        init();
        function toByteArray(b64) {
          let i;
          let j;
          let l;
          let tmp;
          let placeHolders;
          let arr;
          const len = b64.length;
          if (len % 4 > 0) {
            throw new Error('Invalid string. Length must be a multiple of 4');
          }
          placeHolders = b64[len - 2] === '=' ? 2 : b64[len - 1] === '=' ? 1 : 0;
          arr = new Arr((len * 3) / 4 - placeHolders);
          l = placeHolders > 0 ? len - 4 : len;
          let L = 0;
          for (i = 0, j = 0; i < l; i += 4, j += 3) {
            tmp =
              (revLookup[b64.charCodeAt(i)] << 18) |
              (revLookup[b64.charCodeAt(i + 1)] << 12) |
              (revLookup[b64.charCodeAt(i + 2)] << 6) |
              revLookup[b64.charCodeAt(i + 3)];
            arr[L++] = (tmp >> 16) & 255;
            arr[L++] = (tmp >> 8) & 255;
            arr[L++] = tmp & 255;
          }
          if (placeHolders === 2) {
            tmp = (revLookup[b64.charCodeAt(i)] << 2) | (revLookup[b64.charCodeAt(i + 1)] >> 4);

            arr[L++] = tmp & 255;
          } else if (placeHolders === 1) {
            tmp =
              (revLookup[b64.charCodeAt(i)] << 10) |
              (revLookup[b64.charCodeAt(i + 1)] << 4) |
              (revLookup[b64.charCodeAt(i + 2)] >> 2);
            arr[L++] = (tmp >> 8) & 255;
            arr[L++] = tmp & 255;
          }
          return arr;
        }
        function tripletToBase64(num) {
          return (
            lookup[(num >> 18) & 63] +
            lookup[(num >> 12) & 63] +
            lookup[(num >> 6) & 63] +
            lookup[num & 63]
          );
        }
        function encodeChunk(uint8, start, end) {
          let tmp;
          const output = [];
          for (let i = start; i < end; i += 3) {
            tmp = (uint8[i] << 16) + (uint8[i + 1] << 8) + uint8[i + 2];
            output.push(tripletToBase64(tmp));
          }
          return output.join('');
        }
        function fromByteArray(uint8) {
          let tmp;
          const len = uint8.length;
          const extraBytes = len % 3;
          let output = '';
          const parts = [];
          const maxChunkLength = 16383;
          for (let i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) {
            parts.push(
              encodeChunk(uint8, i, i + maxChunkLength > len2 ? len2 : i + maxChunkLength)
            );
          }
          if (extraBytes === 1) {
            tmp = uint8[len - 1];
            output += lookup[tmp >> 2];
            output += lookup[(tmp << 4) & 63];
            output += '==';
          } else if (extraBytes === 2) {
            tmp = (uint8[len - 2] << 8) + uint8[len - 1];
            output += lookup[tmp >> 10];
            output += lookup[(tmp >> 4) & 63];
            output += lookup[(tmp << 2) & 63];
            output += '=';
          }
          parts.push(output);
          return parts.join('');
        }
      },
      {}
    ],
    8: [
      function (require, module, exports) {
        exports.read = function (buffer, offset, isLE, mLen, nBytes) {
          let e;
          let m;
          const eLen = nBytes * 8 - mLen - 1;
          const eMax = (1 << eLen) - 1;
          const eBias = eMax >> 1;
          let nBits = -7;
          let i = isLE ? nBytes - 1 : 0;
          const d = isLE ? -1 : 1;
          let s = buffer[offset + i];
          i += d;
          e = s & ((1 << -nBits) - 1);
          s >>= -nBits;
          nBits += eLen;
          for (; nBits > 0; e = e * 256 + buffer[offset + i], i += d, nBits -= 8) {}
          m = e & ((1 << -nBits) - 1);
          e >>= -nBits;
          nBits += mLen;
          for (; nBits > 0; m = m * 256 + buffer[offset + i], i += d, nBits -= 8) {}
          if (e === 0) {
            e = 1 - eBias;
          } else if (e === eMax) {
            return m ? NaN : (s ? -1 : 1) * Infinity;
          } else {
            m += Math.pow(2, mLen);
            e -= eBias;
          }
          return (s ? -1 : 1) * m * Math.pow(2, e - mLen);
        };
        exports.write = function (buffer, value, offset, isLE, mLen, nBytes) {
          let e;
          let m;
          let c;
          let eLen = nBytes * 8 - mLen - 1;
          const eMax = (1 << eLen) - 1;
          const eBias = eMax >> 1;
          const rt = mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0;
          let i = isLE ? 0 : nBytes - 1;
          const d = isLE ? 1 : -1;
          const s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0;
          value = Math.abs(value);
          if (isNaN(value) || value === Infinity) {
            m = isNaN(value) ? 1 : 0;
            e = eMax;
          } else {
            e = Math.floor(Math.log(value) / Math.LN2);
            if (value * (c = Math.pow(2, -e)) < 1) {
              e--;
              c *= 2;
            }
            if (e + eBias >= 1) {
              value += rt / c;
            } else {
              value += rt * Math.pow(2, 1 - eBias);
            }
            if (value * c >= 2) {
              e++;
              c /= 2;
            }
            if (e + eBias >= eMax) {
              m = 0;
              e = eMax;
            } else if (e + eBias >= 1) {
              m = (value * c - 1) * Math.pow(2, mLen);
              e += eBias;
            } else {
              m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen);
              e = 0;
            }
          }
          for (; mLen >= 8; buffer[offset + i] = m & 255, i += d, m /= 256, mLen -= 8) {}
          e = (e << mLen) | m;
          eLen += mLen;
          for (; eLen > 0; buffer[offset + i] = e & 255, i += d, e /= 256, eLen -= 8) {}
          buffer[offset + i - d] |= s * 128;
        };
      },
      {}
    ],
    9: [
      function (require, module, exports) {
        const { toString } = {};
        module.exports =
          Array.isArray ||
          function (arr) {
            return toString.call(arr) == '[object Array]';
          };
      },
      {}
    ]
  },
  {},
  [5]
);
